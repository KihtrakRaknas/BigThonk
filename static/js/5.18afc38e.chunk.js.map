{"version":3,"sources":["../node_modules/autotrack/lib/store.js","../node_modules/autotrack/lib/event-emitter.js","../node_modules/autotrack/lib/session.js","../node_modules/autotrack/lib/plugins/page-visibility-tracker.js"],"names":["browserSupportsLocalStorage","EventEmitter","this","registry_","event","fn","getRegistry_","push","undefined","eventRegistry","handlerIndex","indexOf","splice","args","forEach","eventCount","Object","keys","length","AUTOTRACK_PREFIX","instances","isListening","Store","key","defaults","key_","defaults_","cache_","trackingId","namespace","join","window","addEventListener","storageListener","localStorage","setItem","removeItem","err","getItem","value","isSupported_","parse","get_","assign","newData","set_","JSON","stringify","clear_","removeEventListener","store","oldData","oldValue","newValue","emit","source","data","Session","tracker","timeout","timeZone","DEFAULT_TIMEOUT","sendHitTaskOverride","bind","MethodChain","add","dateTimeFormatter","Intl","DateTimeFormat","getOrCreate","get","hitTime","isExpired","id","set","uuid","getId","sessionData","oldHitTime","currentDate","Date","oldHitDate","datesAreDifferentInTimezone","d1","d2","format","originalMethod","model","sessionControl","sessionWillStart","sessionWillEnd","now","remove","destroy","VISIBLE","PAGE_ID","PageVisibilityTracker","opts","trackUsage","plugins","PAGE_VISIBILITY_TRACKER","document","visibilityState","defaultOpts","sessionTimeout","visibleThreshold","sendInitialPageview","fieldsObj","lastPageState","visibleThresholdTimeout_","isInitialPageviewSent_","trackerSetOverride","handleChange","handleWindowUnload","handleExternalStoreSet","on","session","deferUntilPluginsLoaded","sendPageview","isPageLoad","time","state","pageId","sessionId","pageLoadsMetricIndex","sendPageLoad","lastStoredChange","getAndValidateChangeData","change","clearTimeout","clear","setTimeout","sendPageVisibilityEvent","delta","getTimeSinceLastStoredChange","deltaInSeconds","Math","round","defaultFields","transport","nonInteraction","eventCategory","eventAction","eventValue","eventLabel","NULL_DIMENSION","queueTime","visibleMetricIndex","send","createFieldsObj","hitFilter","field","fields","isObject","page","provide"],"mappings":"yHA2BIA,E,gECNiBC,E,WAInB,aAAc,oBACZC,KAAKC,UAAY,G,+CAShBC,EAAOC,GACRH,KAAKI,aAAaF,GAAOG,KAAKF,K,4BAQO,IAAnCD,EAAmC,4DAA3BI,EAAWH,EAAgB,4DAAXG,EAC1B,GAAIJ,GAASC,EAAI,CACf,IAAMI,EAAgBP,KAAKI,aAAaF,GAClCM,EAAeD,EAAcE,QAAQN,GACvCK,GAAgB,GAClBD,EAAcG,OAAOF,EAAc,QAGrCR,KAAKC,UAAY,K,2BAShBC,GAAgB,2BAANS,EAAM,iCAANA,EAAM,kBACnBX,KAAKI,aAAaF,GAAOU,SAAQ,SAACT,GAAD,OAAQA,EAAE,WAAF,EAAMQ,Q,sCAOjC,WACVE,EAAa,EAIjB,OAHAC,OAAOC,KAAKf,KAAKC,WAAWW,SAAQ,SAACV,GACnCW,GAAc,EAAKT,aAAaF,GAAOc,UAElCH,I,mCAUIX,GACX,OAAOF,KAAKC,UAAUC,GAAUF,KAAKC,UAAUC,IAAU,O,cDhEvDe,EAAmB,YACnBC,EAAY,GACdC,GAAc,EAUGC,E,kDA2EnB,WAAYC,GAAoB,MAAfC,EAAe,uDAAJ,GAAI,4BAC9B,gBACKC,KAAOF,EACZ,EAAKG,UAAYF,EAGjB,EAAKG,OAAS,KANgB,E,6DAlEbC,EAAYC,EAAWL,GACxC,IAAMD,EAAM,CAACJ,EAAkBS,EAAYC,GAAWC,KAAK,KAO3D,OAJKV,EAAUG,KACbH,EAAUG,GAAO,IAAID,EAAMC,EAAKC,GAC3BH,IA8ITU,OAAOC,iBAAiB,UAAWC,GACnCZ,GAAc,IA7ILD,EAAUG,K,qCAWjB,GAAmC,MAA/BvB,EACF,OAAOA,EAGT,IACE+B,OAAOG,aAAaC,QAAQhB,EAAkBA,GAC9CY,OAAOG,aAAaE,WAAWjB,GAC/BnB,GAA8B,EAC9B,MAAOqC,GACPrC,GAA8B,EAEhC,OAAOA,I,2BASGuB,GACV,OAAOQ,OAAOG,aAAaI,QAAQf,K,2BASzBA,EAAKgB,GACfR,OAAOG,aAAaC,QAAQZ,EAAKgB,K,6BAQrBhB,GACZQ,OAAOG,aAAaE,WAAWb,O,2CAyB/B,GAAIrB,KAAKyB,OACP,OAAOzB,KAAKyB,OAEZ,GAAIL,EAAMkB,eACR,IACEtC,KAAKyB,OAASc,EAAMnB,EAAMoB,KAAKxC,KAAKuB,OACpC,MAAMY,IAIV,OAAOnC,KAAKyB,OAASgB,YAAO,GAAIzC,KAAKwB,UAAWxB,KAAKyB,U,0BASrDiB,GAGF,GAFA1C,KAAKyB,OAASgB,YAAO,GAAIzC,KAAKwB,UAAWxB,KAAKyB,OAAQiB,GAElDtB,EAAMkB,eACR,IACElB,EAAMuB,KAAK3C,KAAKuB,KAAMqB,KAAKC,UAAU7C,KAAKyB,SAC1C,MAAMU,O,8BAWV,GADAnC,KAAKyB,OAAS,GACVL,EAAMkB,eACR,IACElB,EAAM0B,OAAO9C,KAAKuB,MAClB,MAAMY,O,uCAYHjB,EAAUlB,KAAKuB,MACjBT,OAAOC,KAAKG,GAAWF,SAsB9Ba,OAAOkB,oBAAoB,UAAWhB,GACtCZ,GAAc,O,GAxKmBpB,GAgLnC,SAASgC,EAAgB7B,GACvB,IAAM8C,EAAQ9B,EAAUhB,EAAMmB,KAC9B,GAAI2B,EAAO,CACT,IAAMC,EAAUR,YAAO,GAAIO,EAAMxB,UAAWe,EAAMrC,EAAMgD,WAClDR,EAAUD,YAAO,GAAIO,EAAMxB,UAAWe,EAAMrC,EAAMiD,WAExDH,EAAMvB,OAASiB,EACfM,EAAMI,KAAK,cAAeV,EAASO,IAUvC,SAASV,EAAMc,GACb,IAAIC,EAAO,GACX,GAAID,EACF,IACEC,EAA+BV,KAAKL,MAAMc,GAC1C,MAAMlB,IAIV,OAAOmB,EErNT,IAIMpC,EAAY,GAOGqC,E,WAoCnB,WAAYC,EAASC,EAASC,GAAU,oBACtC1D,KAAKwD,QAAUA,EACfxD,KAAKyD,QAAUA,GAAWF,EAAQI,gBAClC3D,KAAK0D,SAAWA,EAGhB1D,KAAK4D,oBAAsB5D,KAAK4D,oBAAoBC,KAAK7D,MAGzD8D,IAAYC,IAAIP,EAAS,cAAexD,KAAK4D,qBAM7C,IACE5D,KAAKgE,kBACD,IAAIC,KAAKC,eAAe,QAAS,CAACR,SAAU1D,KAAK0D,WACrD,MAAMvB,IASRnC,KAAKgD,MAAQ5B,EAAM+C,YACfX,EAAQY,IAAI,cAAe,UALV,CACnBC,QAAS,EACTC,WAAW,IAMRtE,KAAKgD,MAAMoB,MAAMG,IACpBvE,KAAKgD,MAAMwB,IAAqC,CAACD,GAAIE,gB,6DArDtCjB,EAASC,EAASC,GAEnC,IAAMhC,EAAa8B,EAAQY,IAAI,cAC/B,OAAIlD,EAAUQ,GACLR,EAAUQ,GAEVR,EAAUQ,GAAc,IAAI6B,EAAQC,EAASC,EAASC,O,6CAwD/D,OAAO1D,KAAKgD,MAAMoB,MAAMG,K,kCAmBG,IAAnBA,EAAmB,uDAAdvE,KAAK0E,QAIlB,GAAIH,GAAMvE,KAAK0E,QAAS,OAAO,EAG/B,IAAMC,EAAc3E,KAAKgD,MAAMoB,MAI/B,GAAIO,EAAYL,UAAW,OAAO,EAElC,IAAMM,EAAaD,EAAYN,QAK/B,GAAIO,EAAY,CACd,IAAMC,EAAc,IAAIC,KAClBC,EAAa,IAAID,KAAKF,GAC5B,GAAIC,EAAcE,EA/HR,IA+HsB/E,KAAKyD,SACjCzD,KAAKgF,4BAA4BH,EAAaE,GAChD,OAAO,EAKX,OAAO,I,kDAWmBE,EAAIC,GAC9B,QAAKlF,KAAKgE,mBAGDhE,KAAKgE,kBAAkBmB,OAAOF,IAC9BjF,KAAKgE,kBAAkBmB,OAAOD,K,0CAYrBE,GAAgB,WAClC,OAAO,SAACC,GACND,EAAeC,GAEf,IAAMC,EAAiBD,EAAMjB,IAAI,kBAC3BmB,EAAqC,SAAlBD,GAA6B,EAAKhB,YACrDkB,EAAmC,OAAlBF,EAGjBX,EAAc,EAAK3B,MAAMoB,MAC/BO,EAAYN,QAAUoB,cAClBF,IACFZ,EAAYL,WAAY,EACxBK,EAAYJ,GAAKE,eAEfe,IACFb,EAAYL,WAAY,GAE1B,EAAKtB,MAAMwB,IAAIG,M,gCAUjBb,IAAY4B,OAAO1F,KAAKwD,QAAS,cAAexD,KAAK4D,qBACrD5D,KAAKgD,MAAM2C,iBACJzE,EAAUlB,KAAKwD,QAAQY,IAAI,mB,KAKtCb,EAAQI,gBAAkB,G,aChMpBiC,EAAU,UACVC,EAAUpB,cAQVqB,E,WAMJ,WAAYtC,EAASuC,GAAM,WAIzB,GAJyB,oBACzBC,YAAWxC,EAASyC,IAAQC,yBAGvBC,SAASC,gBAAd,CAGA,IAAMC,EAAc,CAClBC,eAAgB/C,EAAQI,gBACxB4C,iBAAkB,IAElBC,qBAAqB,EAGrBC,UAAW,IAIbzG,KAAK+F,KACDtD,YAAO4D,EAAaN,GAExB/F,KAAKwD,QAAUA,EACfxD,KAAK0G,cAAgBP,SAASC,gBAC9BpG,KAAK2G,yBAA2B,KAChC3G,KAAK4G,wBAAyB,EAG9B5G,KAAK6G,mBAAqB7G,KAAK6G,mBAAmBhD,KAAK7D,MACvDA,KAAK8G,aAAe9G,KAAK8G,aAAajD,KAAK7D,MAC3CA,KAAK+G,mBAAqB/G,KAAK+G,mBAAmBlD,KAAK7D,MACvDA,KAAKgH,uBAAyBhH,KAAKgH,uBAAuBnD,KAAK7D,MAG/DA,KAAKgD,MAAQ5B,EAAM+C,YACfX,EAAQY,IAAI,cAAe,mCAC/BpE,KAAKgD,MAAMiE,GAAG,cAAejH,KAAKgH,wBAGlChH,KAAKkH,QAAU3D,EAAQY,YACnBX,EAASxD,KAAK+F,KAAKO,eAAgBtG,KAAK+F,KAAKrC,UAGjDI,IAAYC,IAAIP,EAAS,MAAOxD,KAAK6G,oBAErChF,OAAOC,iBAAiB,SAAU9B,KAAK+G,oBACvCZ,SAASrE,iBAAiB,mBAAoB9B,KAAK8G,cAInDK,YAAwBnH,KAAKwD,SAAS,WAChC2C,SAASC,iBAAmBR,GAC1B,EAAKG,KAAKS,sBACZ,EAAKY,aAAa,CAACC,YAAY,IAC/B,EAAKT,wBAAyB,GAEhC,EAAK5D,MAAMwB,IAA4C,CACrD8C,KAAM7B,cACN8B,MAAO3B,EACP4B,OAAQ3B,EACR4B,UAAW,EAAKP,QAAQxC,WAGtB,EAAKqB,KAAKS,qBAAuB,EAAKT,KAAK2B,sBAC7C,EAAKC,mB,2DAgBE,WACb,GAAMxB,SAASC,iBAAmBR,GAhGvB,UAiGPO,SAASC,gBADb,CAKA,IAAMwB,EAAmB5H,KAAK6H,2BAGxBC,EAAS,CACbR,KAAM7B,cACN8B,MAAOpB,SAASC,gBAChBoB,OAAQ3B,EACR4B,UAAWzH,KAAKkH,QAAQxC,SAMtByB,SAASC,iBAAmBR,GAC5B5F,KAAK+F,KAAKS,sBAAwBxG,KAAK4G,yBACzC5G,KAAKoH,eACLpH,KAAK4G,wBAAyB,GArHrB,UA0HPT,SAASC,iBAA6BpG,KAAK2G,0BAC7CoB,aAAa/H,KAAK2G,0BAGhB3G,KAAKkH,QAAQ5C,UAAUsD,EAAiBH,YAC1CzH,KAAKgD,MAAMgF,QA/HF,UAgILhI,KAAK0G,eACLP,SAASC,iBAAmBR,IAY9BmC,aAAa/H,KAAK2G,0BAClB3G,KAAK2G,yBAA2BsB,YAAW,WACzC,EAAKjF,MAAMwB,IAAIsD,GACf,EAAKV,aAAa,CAAC/C,QAASyD,EAAOR,SAClCtH,KAAK+F,KAAKQ,qBAGXqB,EAAiBJ,QAAU3B,GAC3B+B,EAAiBL,OAAS3B,GAC5B5F,KAAKkI,wBAAwBN,GAE/B5H,KAAKgD,MAAMwB,IAAIsD,IAGjB9H,KAAK0G,cAAgBP,SAASC,mB,iDAoB9B,IAAMwB,EACsC5H,KAAKgD,MAAMoB,MASvD,OAPIpE,KAAK0G,eAAiBd,GAlLf,UAmLPgC,EAAiBL,OACjBK,EAAiBJ,QAAU3B,IAC7B+B,EAAiBL,MAAQ3B,EACzBgC,EAAiBJ,OAAS3B,EAC1B7F,KAAKgD,MAAMwB,IAAIoD,IAEVA,I,8CAYeA,GAAkC,6DAAJ,GAAXvD,EAAe,EAAfA,QACnC8D,EAAQnI,KAAKoI,6BACfR,EAAkB,CAACvD,YAGvB,GAAI8D,GAASA,GAASnI,KAAK+F,KAAKQ,iBAAkB,CAChD,IAAM8B,EAAiBC,KAAKC,MAAMJ,EAxMxB,KA2MJK,EAAgB,CACpBC,UAAW,SACXC,gBAAgB,EAChBC,cAAe,kBACfC,YAAa,QACbC,WAAYR,EACZS,WAAYC,KAGV1E,IACFmE,EAAcQ,UAAYvD,cAAQpB,GAIhCrE,KAAK+F,KAAKkD,qBACZT,EAAc,SAAWxI,KAAK+F,KAAKkD,oBAAsBZ,GAG3DrI,KAAKwD,QAAQ0F,KAAK,QACdC,YAAgBX,EAAexI,KAAK+F,KAAKU,UACrCzG,KAAKwD,QAASxD,KAAK+F,KAAKqD,e,qCAOrB,MAEPZ,GAAa,GACjBC,UAAW,SACXE,cAAe,kBACfC,YAAa,YACbE,WAAYC,KAJK,cAKhB,SAAW/I,KAAK+F,KAAK2B,qBAAuB,GAL5B,gCAMD,GANC,GAQnB1H,KAAKwD,QAAQ0F,KAAK,QACdC,YAAgBX,EAAexI,KAAK+F,KAAKU,UACrCzG,KAAKwD,QAASxD,KAAK+F,KAAKqD,c,qCAYO,6DAAJ,GAAvB/E,EAA2B,EAA3BA,QAASgD,EAAkB,EAAlBA,WAEfmB,EAAgB,CAACC,UAAW,UAC9BpE,IACFmE,EAAcQ,UAAYvD,cAAQpB,GAEhCgD,GAAcrH,KAAK+F,KAAK2B,uBAC1Bc,EAAc,SAAWxI,KAAK+F,KAAK2B,sBAAwB,GAG7D1H,KAAKwD,QAAQ0F,KAAK,WACdC,YAAgBX,EAAexI,KAAK+F,KAAKU,UACrCzG,KAAKwD,QAASxD,KAAK+F,KAAKqD,c,yCAUfhE,GAAgB,WACjC,OAAO,SAACiE,EAAOhH,GAEb,IAAMiH,EAASC,YAASF,GAASA,EAAlB,eAA4BA,EAAQhH,GAC/CiH,EAAOE,MAAQF,EAAOE,OAAS,EAAKhG,QAAQY,IAAI,SAC9C,EAAKsC,eAAiBd,GACxB,EAAKkB,eAGT1B,EAAeiE,EAAOhH,M,mDAYGuF,GAAkC,6DAAJ,GAAXvD,EAAe,EAAfA,QAC9C,OAAOuD,EAAiBN,MACnBjD,GAAWoB,eAASmC,EAAiBN,KAAO,I,6CAY5B5E,EAASO,GAI1BP,EAAQ4E,MAAQrE,EAAQqE,OAOxBrE,EAAQuE,QAAU3B,GAClB5C,EAAQsE,OAAS3B,GAChB5F,KAAKkH,QAAQ5C,UAAUrB,EAAQwE,YAClCzH,KAAKkI,wBAAwBjF,EAAS,CAACoB,QAAS3B,EAAQ4E,U,2CAxU/C,UAsVPtH,KAAK0G,eACP1G,KAAK8G,iB,+BAQP9G,KAAKgD,MAAM2C,UACX3F,KAAKkH,QAAQvB,UACb7B,IAAY4B,OAAO1F,KAAKwD,QAAS,MAAOxD,KAAK6G,oBAC7ChF,OAAOkB,oBAAoB,SAAU/C,KAAK+G,oBAC1CZ,SAASpD,oBAAoB,mBAAoB/C,KAAK8G,kB,KAK1D2C,YAAQ,wBAAyB3D","file":"static/js/5.18afc38e.chunk.js","sourcesContent":["/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport EventEmitter from './event-emitter';\nimport {assign} from './utilities';\n\n\nconst AUTOTRACK_PREFIX = 'autotrack';\nconst instances = {};\nlet isListening = false;\n\n\n/** @type {boolean|undefined} */\nlet browserSupportsLocalStorage;\n\n\n/**\n * A storage object to simplify interacting with localStorage.\n */\nexport default class Store extends EventEmitter {\n  /**\n   * Gets an existing instance for the passed arguements or creates a new\n   * instance if one doesn't exist.\n   * @param {string} trackingId The tracking ID for the GA property.\n   * @param {string} namespace A namespace unique to this store.\n   * @param {Object=} defaults An optional object of key/value defaults.\n   * @return {Store} The Store instance.\n   */\n  static getOrCreate(trackingId, namespace, defaults) {\n    const key = [AUTOTRACK_PREFIX, trackingId, namespace].join(':');\n\n    // Don't create multiple instances for the same tracking Id and namespace.\n    if (!instances[key]) {\n      instances[key] = new Store(key, defaults);\n      if (!isListening) initStorageListener();\n    }\n    return instances[key];\n  }\n\n  /**\n   * Returns true if the browser supports and can successfully write to\n   * localStorage. The results is cached so this method can be invoked many\n   * times with no extra performance cost.\n   * @private\n   * @return {boolean}\n   */\n  static isSupported_() {\n    if (browserSupportsLocalStorage != null) {\n      return browserSupportsLocalStorage;\n    }\n\n    try {\n      window.localStorage.setItem(AUTOTRACK_PREFIX, AUTOTRACK_PREFIX);\n      window.localStorage.removeItem(AUTOTRACK_PREFIX);\n      browserSupportsLocalStorage = true;\n    } catch (err) {\n      browserSupportsLocalStorage = false;\n    }\n    return browserSupportsLocalStorage;\n  }\n\n  /**\n   * Wraps the native localStorage method for each stubbing in tests.\n   * @private\n   * @param {string} key The store key.\n   * @return {string|null} The stored value.\n   */\n  static get_(key) {\n    return window.localStorage.getItem(key);\n  }\n\n  /**\n   * Wraps the native localStorage method for each stubbing in tests.\n   * @private\n   * @param {string} key The store key.\n   * @param {string} value The value to store.\n   */\n  static set_(key, value) {\n    window.localStorage.setItem(key, value);\n  }\n\n  /**\n   * Wraps the native localStorage method for each stubbing in tests.\n   * @private\n   * @param {string} key The store key.\n   */\n  static clear_(key) {\n    window.localStorage.removeItem(key);\n  }\n\n  /**\n   * @param {string} key A key unique to this store.\n   * @param {Object=} defaults An optional object of key/value defaults.\n   */\n  constructor(key, defaults = {}) {\n    super();\n    this.key_ = key;\n    this.defaults_ = defaults;\n\n    /** @type {?Object} */\n    this.cache_ = null; // Will be set after the first get.\n  }\n\n  /**\n   * Gets the data stored in localStorage for this store. If the cache is\n   * already populated, return it as is (since it's always kept up-to-date\n   * and in sync with activity in other windows via the `storage` event).\n   * TODO(philipwalton): Implement schema migrations if/when a new\n   * schema version is introduced.\n   * @return {!Object} The stored data merged with the defaults.\n   */\n  get() {\n    if (this.cache_) {\n      return this.cache_;\n    } else {\n      if (Store.isSupported_()) {\n        try {\n          this.cache_ = parse(Store.get_(this.key_));\n        } catch(err) {\n          // Do nothing.\n        }\n      }\n      return this.cache_ = assign({}, this.defaults_, this.cache_);\n    }\n  }\n\n  /**\n   * Saves the passed data object to localStorage,\n   * merging it with the existing data.\n   * @param {Object} newData The data to save.\n   */\n  set(newData) {\n    this.cache_ = assign({}, this.defaults_, this.cache_, newData);\n\n    if (Store.isSupported_()) {\n      try {\n        Store.set_(this.key_, JSON.stringify(this.cache_));\n      } catch(err) {\n        // Do nothing.\n      }\n    }\n  }\n\n  /**\n   * Clears the data in localStorage for the current store.\n   */\n  clear() {\n    this.cache_ = {};\n    if (Store.isSupported_()) {\n      try {\n        Store.clear_(this.key_);\n      } catch(err) {\n        // Do nothing.\n      }\n    }\n  }\n\n  /**\n   * Removes the store instance for the global instances map. If this is the\n   * last store instance, the storage listener is also removed.\n   * Note: this does not erase the stored data. Use `clear()` for that.\n   */\n  destroy() {\n    delete instances[this.key_];\n    if (!Object.keys(instances).length) {\n      removeStorageListener();\n    }\n  }\n}\n\n\n/**\n * Adds a single storage event listener and flips the global `isListening`\n * flag so multiple events aren't added.\n */\nfunction initStorageListener() {\n  window.addEventListener('storage', storageListener);\n  isListening = true;\n}\n\n\n/**\n * Removes the storage event listener and flips the global `isListening`\n * flag so it can be re-added later.\n */\nfunction removeStorageListener() {\n  window.removeEventListener('storage', storageListener);\n  isListening = false;\n}\n\n\n/**\n * The global storage event listener.\n * @param {!Event} event The DOM event.\n */\nfunction storageListener(event) {\n  const store = instances[event.key];\n  if (store) {\n    const oldData = assign({}, store.defaults_, parse(event.oldValue));\n    const newData = assign({}, store.defaults_, parse(event.newValue));\n\n    store.cache_ = newData;\n    store.emit('externalSet', newData, oldData);\n  }\n}\n\n\n/**\n * Parses a source string as JSON\n * @param {string|null} source\n * @return {!Object} The JSON object.\n */\nfunction parse(source) {\n  let data = {};\n  if (source) {\n    try {\n      data = /** @type {!Object} */ (JSON.parse(source));\n    } catch(err) {\n      // Do nothing.\n    }\n  }\n  return data;\n}\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * An simple reimplementation of the native Node.js EventEmitter class.\n * The goal of this implementation is to be as small as possible.\n */\nexport default class EventEmitter {\n  /**\n   * Creates the event registry.\n   */\n  constructor() {\n    this.registry_ = {};\n  }\n\n  /**\n   * Adds a handler function to the registry for the passed event.\n   * @param {string} event The event name.\n   * @param {!Function} fn The handler to be invoked when the passed\n   *     event is emitted.\n   */\n  on(event, fn) {\n    this.getRegistry_(event).push(fn);\n  }\n\n  /**\n   * Removes a handler function from the registry for the passed event.\n   * @param {string=} event The event name.\n   * @param {Function=} fn The handler to be removed.\n   */\n  off(event = undefined, fn = undefined) {\n    if (event && fn) {\n      const eventRegistry = this.getRegistry_(event);\n      const handlerIndex = eventRegistry.indexOf(fn);\n      if (handlerIndex > -1) {\n        eventRegistry.splice(handlerIndex, 1);\n      }\n    } else {\n      this.registry_ = {};\n    }\n  }\n\n  /**\n   * Runs all registered handlers for the passed event with the optional args.\n   * @param {string} event The event name.\n   * @param {...*} args The arguments to be passed to the handler.\n   */\n  emit(event, ...args) {\n    this.getRegistry_(event).forEach((fn) => fn(...args));\n  }\n\n  /**\n   * Returns the total number of event handlers currently registered.\n   * @return {number}\n   */\n  getEventCount() {\n    let eventCount = 0;\n    Object.keys(this.registry_).forEach((event) => {\n      eventCount += this.getRegistry_(event).length;\n    });\n    return eventCount;\n  }\n\n  /**\n   * Returns an array of handlers associated with the passed event name.\n   * If no handlers have been registered, an empty array is returned.\n   * @private\n   * @param {string} event The event name.\n   * @return {!Array} An array of handler functions.\n   */\n  getRegistry_(event) {\n    return this.registry_[event] = (this.registry_[event] || []);\n  }\n}\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport MethodChain from './method-chain';\nimport Store from './store';\nimport {now, uuid} from './utilities';\n\n\nconst SECONDS = 1000;\nconst MINUTES = 60 * SECONDS;\n\n\nconst instances = {};\n\n\n/**\n * A session management class that helps track session boundaries\n * across multiple open tabs/windows.\n */\nexport default class Session {\n  /**\n   * Gets an existing instance for the passed arguments or creates a new\n   * instance if one doesn't exist.\n   * @param {!Tracker} tracker An analytics.js tracker object.\n   * @param {number} timeout The session timeout (in minutes). This value\n   *     should match what's set in the \"Session settings\" section of the\n   *     Google Analytics admin.\n   * @param {string=} timeZone The optional IANA time zone of the view. This\n   *     value should match what's set in the \"View settings\" section of the\n   *     Google Analytics admin. (Note: this assumes all views for the property\n   *     use the same time zone. If that's not true, it's better not to use\n   *     this feature).\n   * @return {Session} The Session instance.\n   */\n  static getOrCreate(tracker, timeout, timeZone) {\n    // Don't create multiple instances for the same property.\n    const trackingId = tracker.get('trackingId');\n    if (instances[trackingId]) {\n      return instances[trackingId];\n    } else {\n      return instances[trackingId] = new Session(tracker, timeout, timeZone);\n    }\n  }\n\n  /**\n   * @param {!Tracker} tracker An analytics.js tracker object.\n   * @param {number} timeout The session timeout (in minutes). This value\n   *     should match what's set in the \"Session settings\" section of the\n   *     Google Analytics admin.\n   * @param {string=} timeZone The optional IANA time zone of the view. This\n   *     value should match what's set in the \"View settings\" section of the\n   *     Google Analytics admin. (Note: this assumes all views for the property\n   *     use the same time zone. If that's not true, it's better not to use\n   *     this feature).\n   */\n  constructor(tracker, timeout, timeZone) {\n    this.tracker = tracker;\n    this.timeout = timeout || Session.DEFAULT_TIMEOUT;\n    this.timeZone = timeZone;\n\n    // Binds methods.\n    this.sendHitTaskOverride = this.sendHitTaskOverride.bind(this);\n\n    // Overrides into the trackers sendHitTask method.\n    MethodChain.add(tracker, 'sendHitTask', this.sendHitTaskOverride);\n\n    // Some browser doesn't support various features of the\n    // `Intl.DateTimeFormat` API, so we have to try/catch it. Consequently,\n    // this allows us to assume the presence of `this.dateTimeFormatter` means\n    // it works in the current browser.\n    try {\n      this.dateTimeFormatter =\n          new Intl.DateTimeFormat('en-US', {timeZone: this.timeZone});\n    } catch(err) {\n      // Do nothing.\n    }\n\n    /** @type {SessionStoreData} */\n    const defaultProps = {\n      hitTime: 0,\n      isExpired: false,\n    };\n    this.store = Store.getOrCreate(\n        tracker.get('trackingId'), 'session', defaultProps);\n\n    // Ensure the session has an ID.\n    if (!this.store.get().id) {\n      this.store.set(/** @type {SessionStoreData} */ ({id: uuid()}));\n    }\n  }\n\n  /**\n   * Returns the ID of the current session.\n   * @return {string}\n   */\n  getId() {\n    return this.store.get().id;\n  }\n\n  /**\n   * Accepts a session ID and returns true if the specified session has\n   * evidentially expired. A session can expire for two reasons:\n   *   - More than 30 minutes has elapsed since the previous hit\n   *     was sent (The 30 minutes number is the Google Analytics default, but\n   *     it can be modified in GA admin \"Session settings\").\n   *   - A new day has started since the previous hit, in the\n   *     specified time zone (should correspond to the time zone of the\n   *     property's views).\n   *\n   * Note: since real session boundaries are determined at processing time,\n   * this is just a best guess rather than a source of truth.\n   *\n   * @param {string} id The ID of a session to check for expiry.\n   * @return {boolean} True if the session has not exp\n   */\n  isExpired(id = this.getId()) {\n    // If a session ID is passed and it doesn't match the current ID,\n    // assume it's from an expired session. If no ID is passed, assume the ID\n    // of the current session.\n    if (id != this.getId()) return true;\n\n    /** @type {SessionStoreData} */\n    const sessionData = this.store.get();\n\n    // `isExpired` will be `true` if the sessionControl field was set to\n    // 'end' on the previous hit.\n    if (sessionData.isExpired) return true;\n\n    const oldHitTime = sessionData.hitTime;\n\n    // Only consider a session expired if previous hit time data exists, and\n    // the previous hit time is greater than that session timeout period or\n    // the hits occurred on different days in the session timezone.\n    if (oldHitTime) {\n      const currentDate = new Date();\n      const oldHitDate = new Date(oldHitTime);\n      if (currentDate - oldHitDate > (this.timeout * MINUTES) ||\n          this.datesAreDifferentInTimezone(currentDate, oldHitDate)) {\n        return true;\n      }\n    }\n\n    // For all other cases return false.\n    return false;\n  }\n\n  /**\n   * Returns true if (and only if) the timezone date formatting is supported\n   * in the current browser and if the two dates are definitively not the\n   * same date in the session timezone. Anything short of this returns false.\n   * @param {!Date} d1\n   * @param {!Date} d2\n   * @return {boolean}\n   */\n  datesAreDifferentInTimezone(d1, d2) {\n    if (!this.dateTimeFormatter) {\n      return false;\n    } else {\n      return this.dateTimeFormatter.format(d1)\n          != this.dateTimeFormatter.format(d2);\n    }\n  }\n\n  /**\n   * Keeps track of when the previous hit was sent to determine if a session\n   * has expired. Also inspects the `sessionControl` field to handles\n   * expiration accordingly.\n   * @param {function(!Model)} originalMethod A reference to the overridden\n   *     method.\n   * @return {function(!Model)}\n   */\n  sendHitTaskOverride(originalMethod) {\n    return (model) => {\n      originalMethod(model);\n\n      const sessionControl = model.get('sessionControl');\n      const sessionWillStart = sessionControl == 'start' || this.isExpired();\n      const sessionWillEnd = sessionControl == 'end';\n\n      /** @type {SessionStoreData} */\n      const sessionData = this.store.get();\n      sessionData.hitTime = now();\n      if (sessionWillStart) {\n        sessionData.isExpired = false;\n        sessionData.id = uuid();\n      }\n      if (sessionWillEnd) {\n        sessionData.isExpired = true;\n      }\n      this.store.set(sessionData);\n    };\n  }\n\n  /**\n   * Restores the tracker's original `sendHitTask` to the state before\n   * session control was initialized and removes this instance from the global\n   * store.\n   */\n  destroy() {\n    MethodChain.remove(this.tracker, 'sendHitTask', this.sendHitTaskOverride);\n    this.store.destroy();\n    delete instances[this.tracker.get('trackingId')];\n  }\n}\n\n\nSession.DEFAULT_TIMEOUT = 30; // minutes\n","/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nimport {NULL_DIMENSION} from '../constants';\nimport MethodChain from '../method-chain';\nimport provide from '../provide';\nimport Session from '../session';\nimport Store from '../store';\nimport {plugins, trackUsage} from '../usage';\nimport {assign, createFieldsObj, deferUntilPluginsLoaded,\n    isObject, now, uuid} from '../utilities';\n\n\nconst HIDDEN = 'hidden';\nconst VISIBLE = 'visible';\nconst PAGE_ID = uuid();\nconst SECONDS = 1000;\n\n\n/**\n * Class for the `pageVisibilityTracker` analytics.js plugin.\n * @implements {PageVisibilityTrackerPublicInterface}\n */\nclass PageVisibilityTracker {\n  /**\n   * Registers outbound link tracking on tracker object.\n   * @param {!Tracker} tracker Passed internally by analytics.js\n   * @param {?Object} opts Passed by the require command.\n   */\n  constructor(tracker, opts) {\n    trackUsage(tracker, plugins.PAGE_VISIBILITY_TRACKER);\n\n    // Feature detects to prevent errors in unsupporting browsers.\n    if (!document.visibilityState) return;\n\n    /** @type {PageVisibilityTrackerOpts} */\n    const defaultOpts = {\n      sessionTimeout: Session.DEFAULT_TIMEOUT,\n      visibleThreshold: 5 * SECONDS,\n      // timeZone: undefined,\n      sendInitialPageview: false,\n      // pageLoadsMetricIndex: undefined,\n      // visibleMetricIndex: undefined,\n      fieldsObj: {},\n      // hitFilter: undefined\n    };\n\n    this.opts = /** @type {PageVisibilityTrackerOpts} */ (\n        assign(defaultOpts, opts));\n\n    this.tracker = tracker;\n    this.lastPageState = document.visibilityState;\n    this.visibleThresholdTimeout_ = null;\n    this.isInitialPageviewSent_ = false;\n\n    // Binds methods to `this`.\n    this.trackerSetOverride = this.trackerSetOverride.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleWindowUnload = this.handleWindowUnload.bind(this);\n    this.handleExternalStoreSet = this.handleExternalStoreSet.bind(this);\n\n    // Creates the store and binds storage change events.\n    this.store = Store.getOrCreate(\n        tracker.get('trackingId'), 'plugins/page-visibility-tracker');\n    this.store.on('externalSet', this.handleExternalStoreSet);\n\n    // Creates the session and binds session events.\n    this.session = Session.getOrCreate(\n        tracker, this.opts.sessionTimeout, this.opts.timeZone);\n\n    // Override the built-in tracker.set method to watch for changes.\n    MethodChain.add(tracker, 'set', this.trackerSetOverride);\n\n    window.addEventListener('unload', this.handleWindowUnload);\n    document.addEventListener('visibilitychange', this.handleChange);\n\n    // Postpone sending any hits until the next call stack, which allows all\n    // autotrack plugins to be required sync before any hits are sent.\n    deferUntilPluginsLoaded(this.tracker, () => {\n      if (document.visibilityState == VISIBLE) {\n        if (this.opts.sendInitialPageview) {\n          this.sendPageview({isPageLoad: true});\n          this.isInitialPageviewSent_ = true;\n        }\n        this.store.set(/** @type {PageVisibilityStoreData} */ ({\n          time: now(),\n          state: VISIBLE,\n          pageId: PAGE_ID,\n          sessionId: this.session.getId(),\n        }));\n      } else {\n        if (this.opts.sendInitialPageview && this.opts.pageLoadsMetricIndex) {\n          this.sendPageLoad();\n        }\n      }\n    });\n  }\n\n  /**\n   * Inspects the last visibility state change data and determines if a\n   * visibility event needs to be tracked based on the current visibility\n   * state and whether or not the session has expired. If the session has\n   * expired, a change to `visible` will trigger an additional pageview.\n   * This method also sends as the event value (and optionally a custom metric)\n   * the elapsed time between this event and the previously reported change\n   * in the same session, allowing you to more accurately determine when users\n   * were actually looking at your page versus when it was in the background.\n   */\n  handleChange() {\n    if (!(document.visibilityState == VISIBLE ||\n        document.visibilityState == HIDDEN)) {\n      return;\n    }\n\n    const lastStoredChange = this.getAndValidateChangeData();\n\n    /** @type {PageVisibilityStoreData} */\n    const change = {\n      time: now(),\n      state: document.visibilityState,\n      pageId: PAGE_ID,\n      sessionId: this.session.getId(),\n    };\n\n    // If the visibilityState has changed to visible and the initial pageview\n    // has not been sent (and the `sendInitialPageview` option is `true`).\n    // Send the initial pageview now.\n    if (document.visibilityState == VISIBLE &&\n        this.opts.sendInitialPageview && !this.isInitialPageviewSent_) {\n      this.sendPageview();\n      this.isInitialPageviewSent_ = true;\n    }\n\n    // If the visibilityState has changed to hidden, clear any scheduled\n    // pageviews waiting for the visibleThreshold timeout.\n    if (document.visibilityState == HIDDEN && this.visibleThresholdTimeout_) {\n      clearTimeout(this.visibleThresholdTimeout_);\n    }\n\n    if (this.session.isExpired(lastStoredChange.sessionId)) {\n      this.store.clear();\n      if (this.lastPageState == HIDDEN &&\n          document.visibilityState == VISIBLE) {\n        // If the session has expired, changes from hidden to visible should\n        // be considered a new pageview rather than a visibility event.\n        // This behavior ensures all sessions contain a pageview so\n        // session-level page dimensions and metrics (e.g. ga:landingPagePath\n        // and ga:entrances) are correct.\n        // Also, in order to prevent false positives, we add a small timeout\n        // that is cleared if the visibilityState changes to hidden shortly\n        // after the change to visible. This can happen if a user is quickly\n        // switching through their open tabs but not actually interacting with\n        // and of them. It can also happen when a user goes to a tab just to\n        // immediately close it. Such cases should not be considered pageviews.\n        clearTimeout(this.visibleThresholdTimeout_);\n        this.visibleThresholdTimeout_ = setTimeout(() => {\n          this.store.set(change);\n          this.sendPageview({hitTime: change.time});\n        }, this.opts.visibleThreshold);\n      }\n    } else {\n      if (lastStoredChange.pageId == PAGE_ID &&\n          lastStoredChange.state == VISIBLE) {\n        this.sendPageVisibilityEvent(lastStoredChange);\n      }\n      this.store.set(change);\n    }\n\n    this.lastPageState = document.visibilityState;\n  }\n\n  /**\n   * Retroactively updates the stored change data in cases where it's known to\n   * be out of sync.\n   * This plugin keeps track of each visiblity change and stores the last one\n   * in localStorage. LocalStorage is used to handle situations where the user\n   * has multiple page open at the same time and we don't want to\n   * double-report page visibility in those cases.\n   * However, a problem can occur if a user closes a page when one or more\n   * visible pages are still open. In such cases it's impossible to know\n   * which of the remaining pages the user will interact with next.\n   * To solve this problem we wait for the next change on any page and then\n   * retroactively update the stored data to reflect the current page as being\n   * the page on which the last change event occured and measure visibility\n   * from that point.\n   * @return {!PageVisibilityStoreData}\n   */\n  getAndValidateChangeData() {\n    const lastStoredChange =\n        /** @type {PageVisibilityStoreData} */ (this.store.get());\n\n    if (this.lastPageState == VISIBLE &&\n        lastStoredChange.state == HIDDEN &&\n        lastStoredChange.pageId != PAGE_ID) {\n      lastStoredChange.state = VISIBLE;\n      lastStoredChange.pageId = PAGE_ID;\n      this.store.set(lastStoredChange);\n    }\n    return lastStoredChange;\n  }\n\n  /**\n   * Sends a Page Visibility event to track the time this page was in the\n   * visible state (assuming it was in that state long enough to meet the\n   * threshold).\n   * @param {!PageVisibilityStoreData} lastStoredChange\n   * @param {{hitTime: (number|undefined)}=} param1\n   *     - hitTime: A hit timestap used to help ensure original order in cases\n   *                where the send is delayed.\n   */\n  sendPageVisibilityEvent(lastStoredChange, {hitTime} = {}) {\n    const delta = this.getTimeSinceLastStoredChange(\n        lastStoredChange, {hitTime});\n\n    // If the detla is greater than the visibileThreshold, report it.\n    if (delta && delta >= this.opts.visibleThreshold) {\n      const deltaInSeconds = Math.round(delta / SECONDS);\n\n      /** @type {FieldsObj} */\n      const defaultFields = {\n        transport: 'beacon',\n        nonInteraction: true,\n        eventCategory: 'Page Visibility',\n        eventAction: 'track',\n        eventValue: deltaInSeconds,\n        eventLabel: NULL_DIMENSION,\n      };\n\n      if (hitTime) {\n        defaultFields.queueTime = now() - hitTime;\n      }\n\n      // If a custom metric was specified, set it equal to the event value.\n      if (this.opts.visibleMetricIndex) {\n        defaultFields['metric' + this.opts.visibleMetricIndex] = deltaInSeconds;\n      }\n\n      this.tracker.send('event',\n          createFieldsObj(defaultFields, this.opts.fieldsObj,\n              this.tracker, this.opts.hitFilter));\n    }\n  }\n\n  /**\n   * Sends a page load event.\n   */\n  sendPageLoad() {\n    /** @type {FieldsObj} */\n    const defaultFields = {\n      transport: 'beacon',\n      eventCategory: 'Page Visibility',\n      eventAction: 'page load',\n      eventLabel: NULL_DIMENSION,\n      ['metric' + this.opts.pageLoadsMetricIndex]: 1,\n      nonInteraction: true,\n    };\n    this.tracker.send('event',\n        createFieldsObj(defaultFields, this.opts.fieldsObj,\n            this.tracker, this.opts.hitFilter));\n  }\n\n  /**\n   * Sends a pageview, optionally calculating an offset if hitTime is passed.\n   * @param {{\n   *   hitTime: (number|undefined),\n   *   isPageLoad: (boolean|undefined)\n   * }=} param1\n   *     hitTime: The timestamp of the current hit.\n   *     isPageLoad: True if this pageview was also a page load.\n   */\n  sendPageview({hitTime, isPageLoad} = {}) {\n    /** @type {FieldsObj} */\n    const defaultFields = {transport: 'beacon'};\n    if (hitTime) {\n      defaultFields.queueTime = now() - hitTime;\n    }\n    if (isPageLoad && this.opts.pageLoadsMetricIndex) {\n      defaultFields['metric' + this.opts.pageLoadsMetricIndex] = 1;\n    }\n\n    this.tracker.send('pageview',\n        createFieldsObj(defaultFields, this.opts.fieldsObj,\n            this.tracker, this.opts.hitFilter));\n  }\n\n  /**\n   * Detects changes to the tracker object and triggers an update if the page\n   * field has changed.\n   * @param {function((Object|string), (string|undefined))} originalMethod\n   *     A reference to the overridden method.\n   * @return {function((Object|string), (string|undefined))}\n   */\n  trackerSetOverride(originalMethod) {\n    return (field, value) => {\n      /** @type {!FieldsObj} */\n      const fields = isObject(field) ? field : {[field]: value};\n      if (fields.page && fields.page !== this.tracker.get('page')) {\n        if (this.lastPageState == VISIBLE) {\n          this.handleChange();\n        }\n      }\n      originalMethod(field, value);\n    };\n  }\n\n  /**\n   * Calculates the time since the last visibility change event in the current\n   * session. If the session has expired the reported time is zero.\n   * @param {PageVisibilityStoreData} lastStoredChange\n   * @param {{hitTime: (number|undefined)}=} param1\n   *     hitTime: The time of the current hit (defaults to now).\n   * @return {number} The time (in ms) since the last change.\n   */\n  getTimeSinceLastStoredChange(lastStoredChange, {hitTime} = {}) {\n    return lastStoredChange.time ?\n        (hitTime || now()) - lastStoredChange.time : 0;\n  }\n\n  /**\n   * Handles responding to the `storage` event.\n   * The code on this page needs to be informed when other tabs or windows are\n   * updating the stored page visibility state data. This method checks to see\n   * if a hidden state is stored when there are still visible tabs open, which\n   * can happen if multiple windows are open at the same time.\n   * @param {PageVisibilityStoreData} newData\n   * @param {PageVisibilityStoreData} oldData\n   */\n  handleExternalStoreSet(newData, oldData) {\n    // If the change times are the same, then the previous write only\n    // updated the active page ID. It didn't enter a new state and thus no\n    // hits should be sent.\n    if (newData.time == oldData.time) return;\n\n    // Page Visibility events must be sent by the tracker on the page\n    // where the original event occurred. So if a change happens on another\n    // page, but this page is where the previous change event occurred, then\n    // this page is the one that needs to send the event (so all dimension\n    // data is correct).\n    if (oldData.pageId == PAGE_ID &&\n        oldData.state == VISIBLE &&\n        !this.session.isExpired(oldData.sessionId)) {\n      this.sendPageVisibilityEvent(oldData, {hitTime: newData.time});\n    }\n  }\n\n  /**\n   * Handles responding to the `unload` event.\n   * Since some browsers don't emit a `visibilitychange` event in all cases\n   * where a page might be unloaded, it's necessary to hook into the `unload`\n   * event to ensure the correct state is always stored.\n   */\n  handleWindowUnload() {\n    // If the stored visibility state isn't hidden when the unload event\n    // fires, it means the visibilitychange event didn't fire as the document\n    // was being unloaded, so we invoke it manually.\n    if (this.lastPageState != HIDDEN) {\n      this.handleChange();\n    }\n  }\n\n  /**\n   * Removes all event listeners and restores overridden methods.\n   */\n  remove() {\n    this.store.destroy();\n    this.session.destroy();\n    MethodChain.remove(this.tracker, 'set', this.trackerSetOverride);\n    window.removeEventListener('unload', this.handleWindowUnload);\n    document.removeEventListener('visibilitychange', this.handleChange);\n  }\n}\n\n\nprovide('pageVisibilityTracker', PageVisibilityTracker);\n"],"sourceRoot":""}